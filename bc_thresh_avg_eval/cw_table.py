"""
① 誤差の各範囲の乱数は「０〜CW」の乱数で生成
"""
# def get_cw_table():
#     return [
#         (0.5, 0.55, 20),
#         (0.55, 0.75, 10),
#         (0.75, 0.9, 5),
#         (0.9, 1.5, 3)
#     ]

"""
② 乱数生成の範囲が　０〜３｜４〜１０｜１１〜１４｜１５〜２０　のように区分けされてる
⇒ 優先度が高いバックオフ時間の決定でコリジョンの抑制につながる？
"""
def get_cw_table():
    return [
        (0.5, 0.55, (19, 20)),
        (0.55, 0.65, (16, 18)),
        (0.65, 1.0, (12, 15)),
        (1.0, 2.0, (6, 11)),
        (2.0, 4.5, (0, 5))
    ]
# def get_cw_table():
#     return [
#         (0.5, 0.55, (14,20)),
#         (0.55, 0.65, (4,13)),
#         (0.65, 1.0, (0, 3)) 
#     ]

            # 諸元
            # deny_list = [
            #     (2,2), (2,3), (2,4),
            #     (3,2), (3,3), (3,4),
            #     (4,2), (4,3), (4,4),
            #     (5,2), (5,3), (5,4),
            #     (6,6), (6,7), (6,8),
            #     (8,5),
            #     (9,5)
            # ]
            # error_threshold = 0.5
            # CW=20

"""
テスト用
"""
# def get_cw_table():
#     return [
#         (1.0, 2.0, (24, 45)),
#         (2.0, 2.5, (19, 23)),
#         (2.5, 3.5, (12, 18)),
#         (3.5, 4.0, (7, 11)),
#         (4.0, 5.0, (0, 6))
#     ]

# deny_list = [
#     (0,0), (0,1)
#     (2,2), (2,3), (2,4), (2,7), (2,8),
#     (3,2), (3,3), (3,4), (3,7), (3,8),
#     (4,2), (4,3), (4,4),
#     (5,2), (5,3), (5,4),
#     (6,1), (6,6), (6,7), (6,8),
#     (7,1), (7,7), (7,8), (7,9),
#     (8,1), (8,5),
#     (9,1), (9,5)
# ]